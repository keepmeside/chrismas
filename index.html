<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Grand Luxury Tree - Christmas Edition</title>
    <style>
        /* Added Playfair Display for better Vietnamese support in body text */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Great+Vibes&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap');

        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(circle at center, #0f2027 0%, #203a43 50%, #2c5364 100%); 
            background-color: #050d1a; 
            font-family: 'Times New Roman', serif; 
            touch-action: none; /* Prevent scrolling on mobile */
        }

        /* --- Intro Card Styles --- */
        #intro-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 200;
            display: flex; justify-content: center; align-items: center;
            background: radial-gradient(circle at center, rgba(20, 30, 48, 0.9) 0%, rgba(36, 59, 85, 0.95) 100%);
            perspective: 1500px;
            transition: opacity 1s ease, visibility 1s;
            overflow: hidden;
        }

        /* Christmas Bokeh Effect */
        .christmas-lights {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .light {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
            opacity: 0;
            animation: floatUp linear infinite;
        }

        /* Red/Gold/White Lights */
        .light:nth-child(odd) { background: radial-gradient(circle, rgba(255, 215, 0, 0.6) 0%, rgba(255, 215, 0, 0) 70%); }
        .light:nth-child(3n) { background: radial-gradient(circle, rgba(255, 100, 100, 0.5) 0%, rgba(255, 0, 0, 0) 70%); }

        @keyframes floatUp {
            0% { transform: translateY(110vh) scale(0.5); opacity: 0; }
            20% { opacity: 0.8; }
            80% { opacity: 0.6; }
            100% { transform: translateY(-10vh) scale(1.2); opacity: 0; }
        }

        /* Wrapper ensures both parts (inside & cover) stay together and centered */
        .card-wrapper {
            width: 300px;
            height: 400px;
            position: relative;
            transform-style: preserve-3d;
            animation: floatCard 4s ease-in-out infinite;
            cursor: pointer;
            z-index: 201;
        }

        .card-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            transform-style: preserve-3d;
            z-index: 2; /* Cover is above the message */
        }

        .card {
            width: 100%;
            height: 100%;
            position: absolute;
            transform-style: preserve-3d;
            transform-origin: left;
            transition: transform 1.6s cubic-bezier(0.25, 0.8, 0.25, 1.25);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        .card.open {
            /* Open to -140deg for a natural reading angle */
            transform: rotateY(-140deg);
        }

        .card-face {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            backface-visibility: hidden;
            border-radius: 5px;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            box-sizing: border-box;
        }

        /* Front Cover */
        .card-front {
            background: linear-gradient(135deg, #800000 0%, #500000 100%);
            border: 2px solid #d4af37;
            z-index: 2;
        }
        .card-front::after {
            content: ''; position: absolute; top: 10px; left: 10px; right: 10px; bottom: 10px;
            border: 1px solid rgba(212, 175, 55, 0.5);
        }

        .front-text {
            font-family: 'Cinzel', serif;
            color: #d4af37;
            font-size: 28px;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 2px;
            text-transform: uppercase; 
            line-height: 1.4;
        }

        /* Inside Left (Back of Cover) - Updated to show image */
        .card-back {
            background: #fffbf0;
            transform: rotateY(180deg);
            z-index: 1;
            border-left: 1px solid #ddd;
            padding: 10px; /* Add padding for frame effect */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .card-memories-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border: 1px solid #d4af37;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
            border-radius: 3px;
        }

        /* Inside Right (Static Base - Message) */
        .card-inside-right {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #fffbf0;
            z-index: 1; /* Below the cover */
            border-radius: 5px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            text-align: center;
            padding: 30px;
            box-sizing: border-box;
        }

        .message-title {
            font-family: 'Great Vibes', cursive;
            color: #800000;
            font-size: 36px;
            margin-bottom: 20px;
        }

        .message-body {
            font-family: 'Playfair Display', serif; /* Changed to better support Vietnamese 'đ' */
            color: #333;
            font-size: 15px; /* Increased slightly for readability */
            line-height: 1.6;
            font-weight: 500;
            min-height: 100px;
            text-transform: none; 
        }

        .enter-hint {
            margin-top: 40px;
            font-size: 10px;
            color: #888;
            letter-spacing: 2px;
            border: 1px solid #ccc;
            padding: 5px 10px;
            border-radius: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes floatCard { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }

        /* --- Main App Styles --- */
        #canvas-container { 
            width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; 
            transition: filter 1.5s ease;
        }
        
        /* Blur class for intro */
        .blurred {
            filter: blur(15px) brightness(0.6);
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; 
            align-items: center;
            padding-top: 40px;
            box-sizing: border-box;
            transition: opacity 1.5s ease;
            opacity: 0; /* Hidden initially */
        }
        
        .ui-visible {
            opacity: 1 !important;
        }

        .ui-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050d1a; z-index: 300;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-out;
        }
        .loader-text {
            color: #d4af37; font-size: 14px; letter-spacing: 4px; margin-top: 20px;
            text-transform: uppercase; font-weight: 100;
        }
        .spinner {
            width: 40px; height: 40px; border: 1px solid rgba(212, 175, 55, 0.2); 
            border-top: 1px solid #d4af37; border-radius: 50%; 
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Typography */
        h1 { 
            color: #fceea7; font-size: 56px; margin: 0; font-weight: 400; 
            letter-spacing: 6px; 
            text-shadow: 0 0 50px rgba(252, 238, 167, 0.6); 
            background: linear-gradient(to bottom, #fff, #eebb66);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-family: 'Cinzel', 'Times New Roman', serif;
            opacity: 0.9;
            transition: opacity 0.5s ease;
            text-align: center;
            width: 90%;
            text-transform: uppercase; 
        }

        /* Controls - Minimal */
        .controls-wrapper {
            position: absolute; 
            top: 30px;          
            right: 30px;        
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            z-index: 20;
            transition: opacity 0.5s ease;
        }
        
        /* Removed .btn-group, .upload-btn, .hint-text styles as they are no longer used */

        input[type="file"] { display: none; }

        /* Webcam feedback */
        #webcam-wrapper {
            position: absolute; 
            bottom: 30px;       
            left: 30px;         
            width: 280px;       
            height: 210px;
            border: 1px solid rgba(212, 175, 55, 0.5); 
            box-shadow: 0 0 20px rgba(0,0,0,0.9);
            border-radius: 4px;
            overflow: hidden; 
            opacity: 0; /* Hidden initially for intro */     
            pointer-events: none;
            z-index: 50;
            background: #000;
            transition: opacity 1.5s ease; 
        }
        
        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); 
        }

        /* Debug info for gestures */
        #debug-info {
            position: absolute;
            bottom: 5px;
            left: 5px;
            color: rgba(212, 175, 55, 0.8);
            font-size: 10px;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 2px 5px;
            pointer-events: none;
        }

        /* --- MOBILE RESPONSIVE STYLES --- */
        @media (max-width: 768px) {
            h1 {
                font-size: 32px;
                letter-spacing: 2px;
                margin-top: 15px;
            }

            .controls-wrapper {
                top: 80px;
                right: 15px;
                transform: scale(0.9);
                transform-origin: top right;
            }

            #webcam-wrapper {
                width: 140px;
                height: 105px;
                bottom: 15px;
                left: 15px;
                border-width: 1px;
            }

            /* Adjust Card for Mobile */
            .card-wrapper {
                width: 280px;
                height: 380px;
            }
            
            .front-text {
                font-size: 26px;
            }
            
            .message-title {
                font-size: 28px;
            }
            
            .message-body {
                font-size: 12px;
            }
        }

        /* Small mobile devices */
        @media (max-width: 380px) {
            .card-wrapper {
                width: 240px;
                height: 340px;
            }
            .front-text { font-size: 22px; }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>
    <!-- Audio Element -->
    <audio id="bg-music" loop>
        <source src="https://upload.wikimedia.org/wikipedia/commons/e/e6/Jingle_Bells_-_Kevin_MacLeod.ogg" type="audio/ogg">
        Your browser does not support the audio element.
    </audio>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">Loading Memories</div>
    </div>

    <!-- Intro Card Overlay -->
    <div id="intro-overlay">
        <!-- Christmas Effects -->
        <div class="christmas-lights">
            <!-- Generating lights via loop helps, but we'll put a few fixed ones for simplicity in HTML -->
            <div class="light" style="left: 10%; width: 20px; height: 20px; animation-duration: 8s; animation-delay: 0s;"></div>
            <div class="light" style="left: 25%; width: 10px; height: 10px; animation-duration: 12s; animation-delay: 2s;"></div>
            <div class="light" style="left: 40%; width: 15px; height: 15px; animation-duration: 10s; animation-delay: 4s;"></div>
            <div class="light" style="left: 60%; width: 25px; height: 25px; animation-duration: 15s; animation-delay: 1s;"></div>
            <div class="light" style="left: 75%; width: 12px; height: 12px; animation-duration: 9s; animation-delay: 3s;"></div>
            <div class="light" style="left: 90%; width: 18px; height: 18px; animation-duration: 11s; animation-delay: 5s;"></div>
            <div class="light" style="left: 15%; width: 8px; height: 8px; animation-duration: 13s; animation-delay: 6s;"></div>
            <div class="light" style="left: 55%; width: 22px; height: 22px; animation-duration: 14s; animation-delay: 2.5s;"></div>
        </div>

        <!-- WRAPPER: Centers everything together -->
        <div class="card-wrapper">
            <!-- The static right side of the card (inside message) -->
            <div class="card-inside-right">
                <div class="message-title">Merry Christmas Thủy Linh</div>
                <div class="message-body"></div> <!-- Empty initially for typing effect -->
                <div class="enter-hint">TAP / CLICK TO OPEN</div>
            </div>

            <!-- The folding left side (cover) -->
            <div class="card-container" id="folding-card">
                <div class="card">
                    <!-- Front Cover -->
                    <div class="card-face card-front">
                        <div class="front-text">Merry Christmas<br>Thủy Linh</div>
                        <div style="font-size: 40px; margin-top: 20px; color: #d4af37;">❄</div>
                    </div>
                    <!-- Back of Cover (Left Inside) - Now with Image from 'image' folder -->
                    <div class="card-face card-back">
                        <!-- Default to ./image/1.jpg -->
                        <img id="card-inside-img" class="card-memories-img" src="./image/1.jpg" onerror="this.src='https://images.unsplash.com/photo-1543589077-47d81606c1bf?q=80&w=600'" alt="Memory">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container" class="blurred"></div>

    <!-- Main UI (Hidden Initially) -->
    <div id="ui-layer">
        <h1>Merry Christmas Thủy Linh</h1>
        <!-- Controls removed as requested -->
        <div class="controls-wrapper"></div>
    </div>

    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline></video>
        <div id="debug-info">Initializing...</div>
        <canvas id="webcam-preview" style="display:none;"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; 
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- 核心配置 ---
        const CONFIG = {
            colors: {
                bg: 0x050d1a, // Midnight Blue
                fog: 0x050d1a,
                champagneGold: 0xffd966, 
                deepGreen: 0x03180a,     
                accentRed: 0x990000,     
            },
            particles: {
                count: 1500,     
                dustCount: 2000, 
                snowCount: 1000,
                treeHeight: 24,  
                treeRadius: 8    
            },
            camera: { z: 50 },
            
            preload: {
                autoScanLocal: true,
                scanCount: 200, 
                images: [
                    'https://images.unsplash.com/photo-1543589077-47d81606c1bf?q=80&w=600', 
                    'https://images.unsplash.com/photo-1576919228236-a097c32a5cd4?q=80&w=600',
                    'https://images.unsplash.com/photo-1512389142860-9c449e58a543?q=80&w=600', 
                    'https://images.unsplash.com/photo-1482638588057-dce9509db949?q=80&w=600',
                ]
            }
        };

        const STATE = {
            inIntro: true, // New State: Currently in Card Intro
            mode: 'TREE', 
            focusIndex: -1, 
            focusTarget: null,
            hand: { detected: false, x: 0, y: 0 },
            rotation: { x: 0, y: 0 } 
        };

        let scene, camera, renderer, composer;
        let mainGroup; 
        let clock = new THREE.Clock();
        let particleSystem = []; 
        let photoMeshGroup = new THREE.Group();
        let handLandmarker, video;
        let caneTexture; 
        let snowSystem; 
        const debugInfo = document.getElementById('debug-info');

        function startTypingMessage() {
            const el = document.querySelector('.message-body');
            if(!el) return;
            
            // Fixed capitalization for "Giáng Sinh" (consistent capital S) and general flow
            const msg = "Chúc em có một mùa Giáng Sinh an lành, hạnh phúc. Mong rằng năm mới sẽ mang đến thật nhiều may mắn cho em và tình cảm của bọn mình ngày càng đi lên nè.";
            el.innerHTML = "";
            let i = 0;
            
            function type() {
                if(i < msg.length) {
                    const char = msg.charAt(i);
                    if(char === '\n') el.innerHTML += '<br>';
                    else el.innerHTML += char;
                    i++;
                    // Randomize typing speed slightly for a natural feel (30ms - 70ms)
                    setTimeout(type, 30 + Math.random() * 40);
                }
            }
            type();
        }

        async function init() {
            initThree();
            setupEnvironment(); 
            setupLights();
            createTextures();
            createParticles(); 
            createDust();
            createSnow(); 
            loadPredefinedImages();
            setupPostProcessing();
            setupEvents();
            
            // Randomize Card Image from separate 'image' folder
            try {
                const imgEl = document.getElementById('card-inside-img');
                if(imgEl) {
                    // Randomly pick a file (1).jpg - (5).jpg from the 'image' folder
                    // Assumes a few images exist there. If not, it falls back to 1.jpg or Unsplash
                    const randIndex = Math.floor(Math.random() * 5) + 1;
                    imgEl.src = `./image/(${randIndex}).jpg`; 
                }
            } catch(e) {}
            
            // Start loading MediaPipe in background
            initMediaPipe().then(() => {
                const loader = document.getElementById('loader');
                loader.style.opacity = 0;
                setTimeout(() => {
                    loader.remove();
                    // Open the card automatically after loading
                    setTimeout(() => {
                        const card = document.querySelector('.card');
                        if(card) card.classList.add('open');
                        
                        // Start typing animation shortly after the card starts opening
                        setTimeout(startTypingMessage, 1000);
                    }, 500);
                }, 800);
            });

            animate();
        }

        // --- 增强版图片加载系统 ---
        function loadPredefinedImages() {
            const loader = new THREE.TextureLoader();
            CONFIG.preload.images.forEach(url => {
                loader.load(url, 
                    (t) => { t.colorSpace = THREE.SRGBColorSpace; addPhotoToScene(t); },
                    undefined,
                    (e) => { console.log(`Skipped: ${url}`); }
                );
            });

            if (CONFIG.preload.autoScanLocal) {
                for (let i = 1; i <= CONFIG.preload.scanCount; i++) {
                    const pathJpg = `./images/(${i}).jpg`;
                    const pathPng = `./images/(${i}).png`;
                    loader.load(pathJpg, 
                        (t) => { t.colorSpace = THREE.SRGBColorSpace; addPhotoToScene(t); },
                        undefined,
                        () => {
                             loader.load(pathPng, 
                                (t) => { t.colorSpace = THREE.SRGBColorSpace; addPhotoToScene(t); },
                                undefined,
                                () => {} 
                             );
                        }
                    );
                }
            }
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.fog, 0.015);

            camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, CONFIG.camera.z); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping; 
            renderer.toneMappingExposure = 2.2; 
            container.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
        }

        function setupEnvironment() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        }

        function setupLights() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);

            const innerLight = new THREE.PointLight(0xffaa00, 2, 20);
            innerLight.position.set(0, 5, 0);
            mainGroup.add(innerLight);

            const spotGold = new THREE.SpotLight(0xffcc66, 1200);
            spotGold.position.set(30, 40, 40);
            spotGold.angle = 0.5;
            spotGold.penumbra = 0.5;
            scene.add(spotGold);

            const spotBlue = new THREE.SpotLight(0x6688ff, 800);
            spotBlue.position.set(-30, 20, -30);
            scene.add(spotBlue);
            
            const fill = new THREE.DirectionalLight(0xffeebb, 0.8);
            fill.position.set(0, 0, 50);
            scene.add(fill);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.65;
            bloomPass.strength = 0.5; 
            bloomPass.radius = 0.4;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        function createTextures() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#880000'; 
            ctx.beginPath();
            for(let i=-128; i<256; i+=32) {
                ctx.moveTo(i, 0); ctx.lineTo(i+32, 128); ctx.lineTo(i+16, 128); ctx.lineTo(i-16, 0);
            }
            ctx.fill();
            caneTexture = new THREE.CanvasTexture(canvas);
            caneTexture.wrapS = THREE.RepeatWrapping;
            caneTexture.wrapT = THREE.RepeatWrapping;
            caneTexture.repeat.set(3, 3);
        }

        // --- Snow System ---
        function createSnow() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const velocities = [];

            const loader = new THREE.TextureLoader();
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.beginPath();
            context.arc(16, 16, 16, 0, Math.PI * 2);
            context.fill();
            const snowTexture = new THREE.CanvasTexture(canvas);

            for (let i = 0; i < CONFIG.particles.snowCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(100);
                const y = THREE.MathUtils.randFloatSpread(60);
                const z = THREE.MathUtils.randFloatSpread(60);
                vertices.push(x, y, z);
                
                velocities.push(
                    Math.random() * 0.2 + 0.1, // fall speed
                    Math.random() * 0.05       // sway speed
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('userData', new THREE.Float32BufferAttribute(velocities, 2));

            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.4,
                map: snowTexture,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const snow = new THREE.Points(geometry, material);
            scene.add(snow);
            snowSystem = snow;
        }

        function updateSnow() {
            if (!snowSystem) return;
            
            const positions = snowSystem.geometry.attributes.position.array;
            const userData = snowSystem.geometry.attributes.userData.array;

            for (let i = 0; i < CONFIG.particles.snowCount; i++) {
                const fallSpeed = userData[i * 2];
                positions[i * 3 + 1] -= fallSpeed;

                const swaySpeed = userData[i * 2 + 1];
                positions[i * 3] += Math.sin(clock.elapsedTime * 2 + i) * swaySpeed * 0.1;

                if (positions[i * 3 + 1] < -30) {
                    positions[i * 3 + 1] = 30;
                    positions[i * 3] = THREE.MathUtils.randFloatSpread(100);
                    positions[i * 3 + 2] = THREE.MathUtils.randFloatSpread(60);
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
        }

        class Particle {
            constructor(mesh, type, isDust = false) {
                this.mesh = mesh;
                this.type = type;
                this.isDust = isDust;
                
                this.posTree = new THREE.Vector3();
                this.posScatter = new THREE.Vector3();
                this.baseScale = mesh.scale.x; 

                const speedMult = (type === 'PHOTO') ? 0.3 : 2.0;

                this.spinSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * speedMult,
                    (Math.random() - 0.5) * speedMult,
                    (Math.random() - 0.5) * speedMult
                );

                this.calculatePositions();
            }

            calculatePositions() {
                if (this.type === 'PHOTO') {
                    this.posTree.set(0, 0, 0); 
                    const rScatter = 8 + Math.random()*12;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    this.posScatter.set(
                        rScatter * Math.sin(phi) * Math.cos(theta),
                        rScatter * Math.sin(phi) * Math.sin(theta),
                        rScatter * Math.cos(phi)
                    );
                    return;
                }

                const h = CONFIG.particles.treeHeight;
                const halfH = h / 2;
                let t = Math.random(); 
                t = Math.pow(t, 0.8); 
                const y = (t * h) - halfH;
                
                let rMax = CONFIG.particles.treeRadius * (1.0 - t); 
                if (rMax < 0.5) rMax = 0.5;

                const angle = t * 50 * Math.PI + Math.random() * Math.PI; 
                const r = rMax * (0.8 + Math.random() * 0.4); 
                this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);

                let rScatter = this.isDust ? (12 + Math.random()*20) : (8 + Math.random()*12);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(
                    rScatter * Math.sin(phi) * Math.cos(theta),
                    rScatter * Math.sin(phi) * Math.sin(theta),
                    rScatter * Math.cos(phi)
                );
            }

            update(dt, mode, focusTargetMesh) {
                let target = this.posTree;
                
                if (mode === 'SCATTER') target = this.posScatter;
                else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) {
                        const desiredWorldPos = new THREE.Vector3(0, 2, 35);
                        const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
                        target = desiredWorldPos.applyMatrix4(invMatrix);
                    } else {
                        target = this.posScatter;
                    }
                }

                const lerpSpeed = (mode === 'FOCUS' && this.mesh === focusTargetMesh) ? 5.0 : 2.0; 
                this.mesh.position.lerp(target, lerpSpeed * dt);

                if (mode === 'SCATTER') {
                    this.mesh.rotation.x += this.spinSpeed.x * dt;
                    this.mesh.rotation.y += this.spinSpeed.y * dt;
                    this.mesh.rotation.z += this.spinSpeed.z * dt; 
                } else if (mode === 'TREE') {
                    if (this.type === 'PHOTO') {
                        this.mesh.lookAt(0, this.mesh.position.y, 0);
                        this.mesh.rotateY(Math.PI);
                    } else {
                        this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt);
                        this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt);
                        this.mesh.rotation.y += 0.5 * dt; 
                    }
                }
                
                if (mode === 'FOCUS' && this.mesh === focusTargetMesh) {
                    this.mesh.lookAt(camera.position); 
                }

                let s = this.baseScale;
                if (this.isDust) {
                    s = this.baseScale * (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id));
                    if (mode === 'TREE') s = 0; 
                } else if (mode === 'SCATTER' && this.type === 'PHOTO') {
                    s = this.baseScale * 2.5; 
                } else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) s = 4.5; 
                    else s = this.baseScale * 0.8; 
                }
                
                this.mesh.scale.lerp(new THREE.Vector3(s,s,s), 4*dt);
            }
        }

        function updatePhotoLayout() {
            const photos = particleSystem.filter(p => p.type === 'PHOTO');
            const count = photos.length;
            if (count === 0) return;

            const h = CONFIG.particles.treeHeight * 0.9;
            const bottomY = -h/2;
            const stepY = h / count;
            const loops = 3;

            photos.forEach((p, i) => {
                const y = bottomY + stepY * i + stepY/2;
                const fullH = CONFIG.particles.treeHeight;
                const normalizedH = (y + fullH/2) / fullH; 

                let rMax = CONFIG.particles.treeRadius * (1.0 - normalizedH);
                if (rMax < 1.0) rMax = 1.0;
                
                const r = rMax + 3.0; 
                const angle = normalizedH * Math.PI * 2 * loops + (Math.PI/4); 

                p.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
            });
        }

        function createParticles() {
            const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32); 
            const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55); 
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.3, 0),
                new THREE.Vector3(0.1, 0.5, 0), new THREE.Vector3(0.3, 0.4, 0)
            ]);
            const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false);

            const goldMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.champagneGold,
                metalness: 1.0, roughness: 0.1,
                envMapIntensity: 2.0, 
                emissive: 0x443300,   
                emissiveIntensity: 0.3
            });

            const greenMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.deepGreen,
                metalness: 0.2, roughness: 0.8,
                emissive: 0x002200,
                emissiveIntensity: 0.2 
            });

            const redMat = new THREE.MeshPhysicalMaterial({
                color: CONFIG.colors.accentRed,
                metalness: 0.3, roughness: 0.2, clearcoat: 1.0,
                emissive: 0x330000
            });
            
            const candyMat = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.4 });

            for (let i = 0; i < CONFIG.particles.count; i++) {
                const rand = Math.random();
                let mesh, type;
                if (rand < 0.40) {
                    mesh = new THREE.Mesh(boxGeo, greenMat);
                    type = 'BOX';
                } else if (rand < 0.70) {
                    mesh = new THREE.Mesh(boxGeo, goldMat);
                    type = 'GOLD_BOX';
                } else if (rand < 0.92) {
                    mesh = new THREE.Mesh(sphereGeo, goldMat);
                    type = 'GOLD_SPHERE';
                } else if (rand < 0.97) {
                    mesh = new THREE.Mesh(sphereGeo, redMat);
                    type = 'RED';
                } else {
                    mesh = new THREE.Mesh(candyGeo, candyMat);
                    type = 'CANE';
                }

                const s = 0.4 + Math.random() * 0.5;
                mesh.scale.set(s,s,s);
                mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
                
                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, type, false));
            }

            // Star
            const starShape = new THREE.Shape();
            const points = 5;
            const outerRadius = 1.5;
            const innerRadius = 0.7; 
            
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points + Math.PI / 2;
                const r = (i % 2 === 0) ? outerRadius : innerRadius;
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                if (i === 0) starShape.moveTo(x, y);
                else starShape.lineTo(x, y);
            }
            starShape.closePath();

            const starGeo = new THREE.ExtrudeGeometry(starShape, {
                depth: 0.4,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelSegments: 2
            });
            starGeo.center(); 

            const starMat = new THREE.MeshStandardMaterial({
                color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 1.0,
                metalness: 1.0, roughness: 0
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.particles.treeHeight/2 + 1.2, 0);
            mainGroup.add(star);
            
            mainGroup.add(photoMeshGroup);
        }

        function createDust() {
            const geo = new THREE.TetrahedronGeometry(0.08, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffeebb, transparent: true, opacity: 0.8 });
            
            for(let i=0; i<CONFIG.particles.dustCount; i++) {
                 const mesh = new THREE.Mesh(geo, mat);
                 mesh.scale.setScalar(0.5 + Math.random());
                 mainGroup.add(mesh);
                 particleSystem.push(new Particle(mesh, 'DUST', true));
            }
        }

        function addPhotoToScene(texture) {
            const frameGeo = new THREE.BoxGeometry(1.4, 1.4, 0.05);
            const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.champagneGold, metalness: 1.0, roughness: 0.1 });
            const frame = new THREE.Mesh(frameGeo, frameMat);

            let width = 1.2;
            let height = 1.2;
            
            if (texture.image) {
                const aspect = texture.image.width / texture.image.height;
                if (aspect > 1) {
                    height = width / aspect;
                } else {
                    width = height * aspect;
                }
            }

            const photoGeo = new THREE.PlaneGeometry(width, height);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.04;

            const group = new THREE.Group();
            group.add(frame);
            group.add(photo);
            
            frame.scale.set(width/1.2, height/1.2, 1);

            const s = 0.8;
            group.scale.set(s,s,s);
            
            photoMeshGroup.add(group);
            particleSystem.push(new Particle(group, 'PHOTO', false));

            updatePhotoLayout();
        }

        // Removed handleImageUpload as it's no longer used

        // --- MEDIAPIPE (Adaptive Fix) ---
        async function initMediaPipe() {
            video = document.getElementById('webcam');
            
            // Prefer front camera (user) for mobile
            const constraints = {
                video: {
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    frameRate: { ideal: 30 },
                    facingMode: "user" 
                }
            };

            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            if (navigator.mediaDevices?.getUserMedia) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", predictWebcam);
                    // Intro has different debug text
                    if (!STATE.inIntro) {
                        debugInfo.innerText = "Webcam active. Show hand.";
                    }
                } catch(e) {
                    console.warn("Webcam access denied or not available", e);
                    debugInfo.innerText = "Camera error: " + e.message;
                    document.getElementById('webcam-wrapper').style.display = 'none';
                }
            }
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (handLandmarker && !STATE.inIntro) { // Only detect gestures if not in intro
                    const result = handLandmarker.detectForVideo(video, performance.now());
                    processGestures(result);
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function processGestures(result) {
            if (result.landmarks && result.landmarks.length > 0) {
                STATE.hand.detected = true;
                const lm = result.landmarks[0];
                STATE.hand.x = (lm[9].x - 0.5) * 2; 
                STATE.hand.y = (lm[9].y - 0.5) * 2;

                const thumb = lm[4]; 
                const index = lm[8]; 
                const wrist = lm[0];
                const middleMCP = lm[9]; 

                const handSize = Math.hypot(middleMCP.x - wrist.x, middleMCP.y - wrist.y);
                if (handSize < 0.02) return;

                const tips = [lm[8], lm[12], lm[16], lm[20]];
                let avgTipDist = 0;
                tips.forEach(t => avgTipDist += Math.hypot(t.x - wrist.x, t.y - wrist.y));
                avgTipDist /= 4;

                const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);

                const extensionRatio = avgTipDist / handSize;
                const pinchRatio = pinchDist / handSize;

                debugInfo.innerText = `Size: ${handSize.toFixed(2)} | Ext: ${extensionRatio.toFixed(2)} | Pinch: ${pinchRatio.toFixed(2)} | Mode: ${STATE.mode}`;

                if (extensionRatio < 1.5) {
                    STATE.mode = 'TREE';
                    STATE.focusTarget = null;
                } else if (pinchRatio < 0.35) {
                    if (STATE.mode !== 'FOCUS') {
                        STATE.mode = 'FOCUS';
                        const photos = particleSystem.filter(p => p.type === 'PHOTO');
                        if (photos.length) STATE.focusTarget = photos[Math.floor(Math.random()*photos.length)].mesh;
                    }
                } else if (extensionRatio > 1.7) {
                    STATE.mode = 'SCATTER';
                    STATE.focusTarget = null;
                }
            } else {
                STATE.hand.detected = false;
                debugInfo.innerText = "No hand detected";
            }
        }

        // --- Music Logic ---
        function playMusic() {
            const audio = document.getElementById('bg-music');
            if(audio && audio.paused) {
                audio.play().catch(e => console.log("Audio autoplay prevented", e));
            }
        }

        // --- Transition Logic ---
        function enterMainExperience() {
            if (!STATE.inIntro) return;
            
            // Try playing music on interaction
            playMusic();

            // 1. Fade out the card overlay
            const overlay = document.getElementById('intro-overlay');
            overlay.style.opacity = '0';
            overlay.style.pointerEvents = 'none';

            // 2. Un-blur the canvas
            document.getElementById('canvas-container').classList.remove('blurred');

            // 3. Show main UI
            document.getElementById('ui-layer').classList.add('ui-visible');
            const webcamWrap = document.getElementById('webcam-wrapper');
            webcamWrap.style.opacity = '1';

            // 4. Update State
            STATE.inIntro = false;
            debugInfo.innerText = "Webcam active. Show hand.";

            // 5. Cleanup DOM after transition
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 1000);
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Removed file input event listeners

            window.addEventListener('keydown', (e) => {
                // Intro Transition
                if (e.key === 'Enter' && STATE.inIntro) {
                    enterMainExperience();
                }

                // UI Toggle
                if (e.key.toLowerCase() === 'h') {
                    const controls = document.querySelector('.controls-wrapper');
                    if (controls) controls.classList.toggle('ui-hidden');
                    const webcam = document.getElementById('webcam-wrapper');
                    if(webcam) webcam.classList.toggle('ui-hidden');
                }
            });
            
            // Click on intro card to enter as well
            document.getElementById('intro-overlay').addEventListener('click', () => {
                 enterMainExperience(); 
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            // Background rotation is slower during intro to be less distracting
            if (STATE.inIntro) {
                mainGroup.rotation.y += 0.1 * dt;
                updateSnow();
                composer.render();
                return; // Skip gesture logic and heavy rotations in intro
            }

            // Standard Logic
            if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
                const targetRotY = STATE.hand.x * Math.PI * 0.9; 
                const targetRotX = STATE.hand.y * Math.PI * 0.25;
                STATE.rotation.y += (targetRotY - STATE.rotation.y) * 3.0 * dt;
                STATE.rotation.x += (targetRotX - STATE.rotation.x) * 3.0 * dt;
            } else {
                if(STATE.mode === 'TREE') {
                    STATE.rotation.y += 0.3 * dt;
                    STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt;
                } else {
                      STATE.rotation.y += 0.1 * dt; 
                }
            }

            mainGroup.rotation.y = STATE.rotation.y;
            mainGroup.rotation.x = STATE.rotation.x;

            particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));
            updateSnow();

            composer.render();
        }

        init();
    </script>
</body>
</html>